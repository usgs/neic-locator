package gov.usgs.locator;

import gov.usgs.locaux.AuthorType;
import gov.usgs.locaux.LocUtil;
import gov.usgs.traveltime.AuxiliaryTTReference;
import gov.usgs.traveltime.BadDepthException;
import gov.usgs.traveltime.TauUtilities;
import gov.usgs.traveltime.TravelTime;
import gov.usgs.traveltime.TravelTimeData;
import gov.usgs.traveltime.TravelTimeSession;
import gov.usgs.traveltime.tables.TauIntegralException;
import java.util.ArrayList;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * The PhaseID class associates theoretical seismic phases with the observed seismicpicks.
 *
 * @author Ray Buland
 */
public class PhaseID {
  /** An Event object containing the event to perform phase identification upon. */
  private Event event;

  /**
   * A Hypocenter object containing the hypocenter of event to perform phase identification upon.
   */
  private Hypocenter hypo;

  /**
   * A TravelTimeSession object containing a local travel-time manager used to perform phase
   * identification.
   */
  private TravelTimeSession travelTimeSession;

  /**
   * An AuxiliaryTTReference object containing a auxiliary travel-time information used to perform
   * phase identification.
   */
  private AuxiliaryTTReference auxiliaryTTInfo;

  /**
   * An ArrayList of WeightedResidual objects containing the weighted residuals of the event picks.
   */
  private ArrayList<WeightedResidual> weightedResiduals;

  /** A PickGroup object, which holds the current pick group being processed by phaseID. */
  private PickGroup currentGroup;

  /** A Pick object containing the last pick identified. */
  private Pick lastPick = null;

  /**
   * A TravelTime object containing the travel time information for all possible phases generated by
   * a source at the event to the current pick group being processed by phaseID.
   */
  private TravelTime currentTTList = null;

  /**
   * A double containing the weight for phases that don't match, used to control figure-of-merit
   * calculations during phaseID.
   */
  private double otherWeight;

  /**
   * A double containing the weight to resist changing identification, used to control
   * figure-of-merit calculations during phaseID.
   */
  private double stickyWeight;

  /**
   * A boolean flag indicating whether the current phase being identified is a generic phase or not.
   */
  private boolean isGeneric = false;

  /**
   * A boolean flag indicating whether the current phase being identified is a primary phase or not.
   */
  private boolean isPrimary = false;

  /** A String containing the last travel time phase group name processed by phaseID. */
  private String currPhaseGroupName = null;

  /** Private logging object. */
  private static final Logger LOGGER = LogManager.getLogger(PhaseID.class.getName());

  /**
   * The PhaseID constructor. This constructor sets the event and tt session to the provided values.
   *
   * @param event An Event object containing the information for the event to perform phase
   *     identification upon.
   * @param travelTimeSession A TravelTimeSession object holding the local travel-time manager
   */
  public PhaseID(Event event, TravelTimeSession travelTimeSession) {
    this.event = event;
    hypo = event.getHypo();
    this.travelTimeSession = travelTimeSession;

    if (travelTimeSession != null) {
      this.auxiliaryTTInfo = travelTimeSession.getAuxTT();
    } else {
      this.auxiliaryTTInfo = null;
    }

    weightedResiduals = event.getRawWeightedResiduals();
  }

  /**
   * The phaseID function performs the the phase identification on the event.
   *
   * @param otherWeight A double containing the weight for phases that don't match the current phase
   *     identification or the current phase group (higher weights make changing to an "other" phase
   *     easier)
   * @param stickyWeight A double containing the weight for an exact match (higher weights make
   *     changing the current identification harder.
   * @param reidentifyPhases If true, do the full phase re-identification, if false try not to
   *     change phase identifications
   * @param reweightResiduals If true, update the residual weights
   * @return True if any used pick in the group has changed significantly
   * @throws BadDepthException If source depth is out of range
   * @throws TauIntegralException If the tau integrals fail
   */
  public boolean phaseID(
      double otherWeight, double stickyWeight, boolean reidentifyPhases, boolean reweightResiduals)
      throws BadDepthException, TauIntegralException {

    LOGGER.debug("Curr loc: " + hypo);

    // Remember the figure-of-merit controls.
    this.otherWeight = otherWeight;
    this.stickyWeight = stickyWeight;

    // Initialize the changed flag.
    boolean changed = false;

    // Reinitialize the weighted residual storage.
    if (weightedResiduals.size() > 0) {
      weightedResiduals.clear();
    }

    // Set up a new travel-time session.
    travelTimeSession.newSession(
        event.getEarthModel(),
        hypo.getDepth(),
        LocUtil.PHASELIST,
        hypo.getLatitude(),
        hypo.getLongitude(),
        LocUtil.SUPRESSUNLIKELYPHASES,
        LocUtil.SUPRESSBACKBRANCHES,
        LocUtil.isTectonic);

    // Do the travel-time calculation for each pick group
    for (int j = 0; j < event.getNumStations(); j++) {
      currentGroup = event.getPickGroupList().get(j);
      Station station = currentGroup.getStation();

      LOGGER.trace(
          String.format(
              "PhaseID: %s %6.2f %6.2f %6.2f",
              station.getStationID().getStationCode(),
              currentGroup.getPicks().get(0).getTravelTime(),
              currentGroup.getDistance(),
              currentGroup.getAzimuth()));

      // For the first pick in the group, get the travel times.
      currentTTList =
          travelTimeSession.getTravelTimes(
              station.getLatitude(),
              station.getLongitude(),
              station.getElevation(),
              currentGroup.getDistance(),
              currentGroup.getAzimuth());

      // If reidentifyPhases is true, do a full phase re-identification for the
      // current group.
      // NOTE this is done using class variables rather than just passing the
      // group in, ick.  NOTE class variables are cool when there are so many
      // interlinked methods!
      if (reidentifyPhases) {
        reidentifyPhases();
      } else {
        // Otherwise, try not to re-identify the phases.
        noReidentification();
      }

      // update changed flag
      if (currentGroup.updatePhaseIdentifications(reweightResiduals, weightedResiduals)) {
        changed = true;
      }
    }

    // Add the Bayesian depth.
    weightedResiduals.add(
        new WeightedResidual(
            null,
            hypo.getBayesianDepthResidual(),
            hypo.getBayesianDepthWeight(),
            true,
            0d,
            0d,
            1d,
            0d,
            0d));

    // Save a copy of weightedResiduals in the original order.
    event.saveWeightedResiduals();

    // Update the station statistics.
    event.computeStationStats();

    return changed;
  }

  /**
   * This function tries to re-identifies only if the identification is invalid. During the location
   * iteration, we don't want to re-identify phases, but sometimes re-identification is thrust upon
   * us (e.g., when the depth or distance changes and the former identification no longer exists).
   */
  private void noReidentification() {
    // NOTE this depends on the current group being set by phaseID
    // Loop over picks in the group.
    for (int j = 0; j < currentGroup.getNumPicks(); j++) {
      Pick pick = currentGroup.getPick(j);
      String phCode = pick.getCurrentPhaseCode();

      if (!"".equals(phCode)) {
        // If we have a non-blank phase code, find the phase of the same name
        // that is closest to the pick in time.
        int ttIndex = -1;
        double minResidual = TauUtilities.MAXIMUMDOUBLE;

        for (int i = 0; i < currentTTList.getNumPhases(); i++) {
          TravelTimeData travelTime = currentTTList.getPhase(i);

          if (phCode.equals(travelTime.getPhaseCode())
              && (Math.abs(pick.getTravelTime() - travelTime.getTravelTime()) < minResidual)) {
            ttIndex = i;
            minResidual = Math.abs(pick.getTravelTime() - travelTime.getTravelTime());
            LOGGER.trace(
                String.format("NoReID: checking for min residual:  %s %6.2f", phCode, minResidual));
          }
        }

        // If it's not too out of whack, force the association.
        if (ttIndex >= 0
            && (minResidual <= LocUtil.ASSOCTOLERANCE
                || "Lg".equals(phCode)
                || "LR".equals(phCode))) {
          pick.setTTStatisticalMinFoM(currentTTList.getPhase(ttIndex));
          pick.setStatisticalFoM(minResidual);
          pick.setForceAssociation(true);

          LOGGER.trace(
              String.format(
                  "NoReID: got it %s %s %6.2f %2d",
                  pick.getStation().getStationID().getStationCode(), phCode, minResidual, ttIndex));
        } else {
          // If the easy way doesn't work, we have to try harder.
          // If we have a non-blank phase code, find the phase of the same name
          // that is closest to the pick in time.
          String phaseGroupName = auxiliaryTTInfo.findGroup(phCode, false);
          ttIndex = -1;
          minResidual = TauUtilities.MAXIMUMDOUBLE;

          for (int i = 0; i < currentTTList.getNumPhases(); i++) {
            TravelTimeData travelTime = currentTTList.getPhase(i);

            if ((phaseGroupName.equals(travelTime.getGroupPhaseCode()))
                && (Math.abs(pick.getTravelTime() - travelTime.getTravelTime()) < minResidual)) {
              ttIndex = i;
              minResidual = Math.abs(pick.getTravelTime() - travelTime.getTravelTime());
            }
          }

          // If it's not too out of whack, force the association.
          if (ttIndex >= 0 && minResidual <= LocUtil.ASSOCTOLERANCE) {
            pick.setTTStatisticalMinFoM(currentTTList.getPhase(ttIndex));
            pick.setStatisticalFoM(minResidual);
            pick.setForceAssociation(true);

            LOGGER.trace(
                String.format(
                    "NoReID: group %s %s -> %s %6.2f %2d",
                    pick.getStation().getStationID().getStationCode(),
                    phCode,
                    currentTTList.getPhase(ttIndex).getPhaseCode(),
                    minResidual,
                    ttIndex));
          } else {
            if (pick.getIsUsed()) {
              LOGGER.trace("NoReID: give up " + pick.getStation().getStationID().getStationCode());

              currentGroup.initializeFoM(j, j);
              reidentifyPhases();
            } else {
              pick.setTTStatisticalMinFoM(null);
            }
          }
        } // end else phase out of wack
      } // end if phase code blank
    } // end loop over picks in the group.
  }

  /**
   * This more sophisticated phase identification is used once we have a decent initial location.
   * Note that for a full phase re-identification the weights are always updated.
   */
  private void reidentifyPhases() {
    // Initialize the figure-of-merit memory.
    currentGroup.initializeFoM(0, currentGroup.getNumPicks());

    // Pre-identify surface waves identified by trusted sources.
    for (int j = 0; j < currentGroup.getNumPicks(); j++) {
      Pick pick = currentGroup.getPick(j);

      if (pick.getIsSurfaceWave()) {
        for (int i = 0; i < currentTTList.getNumPhases(); i++) {
          if (pick.getBestPhaseCode().equals(currentTTList.getPhase(i).getPhaseCode())) {
            pick.setTTStatisticalMinFoM(currentTTList.getPhase(i));
            pick.setForceAssociation(true);
            break;
          }
        }
      }
    }

    // Split the theoretical phase into clusters (groups isolated in
    // travel time).
    LOGGER.trace("Clusters:");

    int i = 0;
    TravelTimeData travelTime = currentTTList.getPhase(0);
    double minTTWindow = travelTime.getTravelTime() - travelTime.getAssocWindow();
    double maxTTWindow = travelTime.getTravelTime() + travelTime.getAssocWindow();
    int firstTTIndex = 0; // Index of the first theoretical arrival
    int numTT = 1; // Number of theoretical arrivals
    int firstPhaseIndex = -1; // Index of the first phase within this phase group
    int numPicks = 0; // Number of picks

    // Loop over theoretical arrivals.
    for (int j = 1; j < currentTTList.getNumPhases(); j++) {
      travelTime = currentTTList.getPhase(j);

      // If this is part of the same cluster, extend the window.
      if (travelTime.getTravelTime() - travelTime.getAssocWindow() <= maxTTWindow) {
        minTTWindow =
            Math.min(minTTWindow, travelTime.getTravelTime() - travelTime.getAssocWindow());
        maxTTWindow =
            Math.max(maxTTWindow, travelTime.getTravelTime() + travelTime.getAssocWindow());
        numTT++;
      } else {
        // This theoretical cluster is done, now associate picks within
        // the current pick group.
        for (; i < currentGroup.getNumPicks(); i++) {
          Pick pick = currentGroup.getPick(i);

          if (pick.getTravelTime() <= maxTTWindow) {
            if (pick.getTravelTime() >= minTTWindow) {
              if (numPicks == 0) {
                firstPhaseIndex = i;
              }
              numPicks++;
            }
          } else {
            break;
          }
        }

        // If this cluster has picks, do the identification.
        if (numPicks > 0) {
          // Print the current cluster.
          LOGGER.trace(
              String.format(
                  "TT: %2d %2d  Pick: %2d %2d  Win: %7.2f %7.2f",
                  firstTTIndex, numTT, firstPhaseIndex, numPicks, minTTWindow, maxTTWindow));

          // Initialize the cumulative figure-of-merit.
          currentGroup.setCumulativeFoM(0d);

          // Do the identification.
          genPhasePermutations(firstPhaseIndex, numPicks, firstTTIndex, numTT);
        }

        // Quit if we're out of picks.
        if (i >= currentGroup.getNumPicks()) {
          break;
        }

        // Otherwise, set up for the next cluster.
        minTTWindow = travelTime.getTravelTime() - travelTime.getAssocWindow();
        maxTTWindow = travelTime.getTravelTime() + travelTime.getAssocWindow();
        firstTTIndex = j;
        numTT = 1;
        firstPhaseIndex = -1;
        numPicks = 0;
      }
    }

    // Apply the distance correction to the first arriving phase.
    double distanceCorrection = LocUtil.computeDistCorr(currentGroup.getDistance());
    if (distanceCorrection > 1d) {
      if (currentGroup.getPick(0).getTTStatisticalMinFoM() != null) {
        currentGroup
            .getPick(0)
            .setStatisticalFoM(currentGroup.getPick(0).getStatisticalFoM() / distanceCorrection);
      }
    }
  }

  /**
   * This function generates combinations of picks or theoretical arrivals to compare with all
   * possible combinations of theoretical arrivals or picks. For example, if there are 3 picks and 5
   * theoretical arrivals, the theoretical arrivals will be taken 3 at a time until all possible
   * combinations in the original order have been generated. Each combination will be treated as a
   * trial phase identification of the picks to those theoretical arrivals.
   *
   * @param firstPhaseIndex An int containing the index of the first phase within this phase group
   *     that will be part of this phase identification
   * @param numPicks An int holding the number of picks to include in this phase identification
   * @param firstTTIndex An int containing the index of the first theoretical arrival that will be
   *     part of this phase identification
   * @param numTT An int holding the number of theoretical arrivals to include in this phase
   *     identification
   */
  private void genPhasePermutations(
      int firstPhaseIndex, int numPicks, int firstTTIndex, int numTT) {
    // Set up some pointer arrays to work with internally.
    Pick[] obsPicks = new Pick[numPicks];
    int i = firstPhaseIndex;
    for (int j = 0; j < numPicks; j++, i++) {
      obsPicks[j] = currentGroup.getPicks().get(i);
    }

    TravelTimeData[] ttArrivals = new TravelTimeData[numTT];
    i = firstTTIndex;
    for (int j = 0; j < numTT; j++, i++) {
      ttArrivals[j] = currentTTList.getPhase(i);
    }

    LOGGER.trace(String.format(" Permut: %2d Picks, %2d TTs", numPicks, numTT));

    // The algorithm depends on which group is the most numerous.
    if (numTT >= numPicks) {
      // Generate the combinations.
      TravelTimeData[] ttPermutation = new TravelTimeData[numPicks];
      genKPermutationsOfN(ttArrivals, numPicks, 0, ttPermutation, obsPicks);
    } else {
      // Generate the combinations.
      Pick[] pickPermutation = new Pick[numTT];
      genKPermutationsOfN(obsPicks, numTT, 0, pickPermutation, ttArrivals);
    }
  }

  /**
   * This function creates all k-permutations of n objects, where k is the length of ttPermutation
   * and n is the length of ttGrp. Note that this algorithm is recursive. The variables length and
   * startIndex are primarily for internal use. For the caller, length should be the length of the
   * result (ttPermutation) and startIndex should be 0. This algorithm has been taken from
   * StackOverflow. It was posted by user935714 on 20 April 2016.
   *
   * @param ttArrivals A TravelTimeData[] containing an array of the theoretical arrivals
   * @param length An int containing the the length of the permutation subset
   * @param startIndex An int containing the starting index of the permutation subset
   * @param ttPermutation A TravelTimeData[] containing the results of the permutation
   * @param obsPicks A Pick[] containing the array of observed picks
   */
  private void genKPermutationsOfN(
      TravelTimeData[] ttArrivals,
      int length,
      int startIndex,
      TravelTimeData[] ttPermutation,
      Pick[] obsPicks) {
    if (length == 0) {
      computeCombinedFoM(obsPicks, ttPermutation);
      return;
    }

    for (int i = startIndex; i <= ttArrivals.length - length; i++) {
      ttPermutation[ttPermutation.length - length] = ttArrivals[i];
      genKPermutationsOfN(ttArrivals, length - 1, i + 1, ttPermutation, obsPicks);
    }
  }

  /**
   * This function creates all k-permutations of n objects, where k is the length of pickPermutation
   * and n is the length of pickGrp. Note that this algorithm is recursive. The variables length and
   * startIndex are primarily for internal use. For the caller, length should be the length of the
   * result (pickPermutation) and startIndex should be 0. This algorithm has been taken from
   * StackOverflow. It was posted by user935714 on 20 April 2016.
   *
   * @param obsPicks A Pick[] containing the array of observed picks
   * @param length An int containing the the length of the permutation subset
   * @param startIndex An int containing the starting index of the permutation subset
   * @param pickPermutation A Pick[] containing the results of the permutation
   * @param ttArrivals A TravelTimeData[] containing an array of the theoretical arrivals
   */
  private void genKPermutationsOfN(
      Pick[] obsPicks,
      int length,
      int startIndex,
      Pick[] pickPermutation,
      TravelTimeData[] ttArrivals) {
    if (length == 0) {
      computeCombinedFoM(pickPermutation, ttArrivals);
      return;
    }

    for (int i = startIndex; i <= obsPicks.length - length; i++) {
      pickPermutation[pickPermutation.length - length] = obsPicks[i];
      genKPermutationsOfN(obsPicks, length - 1, i + 1, pickPermutation, ttArrivals);
    }
  }

  /**
   * This function computes the combined figure(s)-of-merit and saves the best identification
   * results in the picks for later processing for each trial set of phase identifications.
   *
   * @param obsPicks A Pick[] containing the array of observed picks
   * @param ttArrivals A TravelTimeData[] containing an array of the theoretical arrivals
   */
  private void computeCombinedFoM(Pick[] obsPicks, TravelTimeData[] ttArrivals) {
    // Make a pass computing the cumulative statistical figure-of-merit.
    double cumulativeFoM = 1d;

    for (int j = 0; j < ttArrivals.length; j++) {
      if (!obsPicks[j].getIsSurfaceWave()) {
        // Compute the figure-of-merit for the primary criteria.
        double probability =
            LocUtil.computePDFResValue(
                obsPicks[j].getTravelTime() - ttArrivals[j].getTravelTime(),
                0d,
                ttArrivals[j].getStatisticalSpread());
        double observabilityAmp = computeObsAmplitude(obsPicks[j], ttArrivals[j]);
        double residual = computeResidual(obsPicks[j], ttArrivals[j]);
        double boost = LocUtil.computeProximityBoost(residual);

        LOGGER.trace(
            String.format(
                "%s %s: %10.4e %10.4e %5.2f",
                obsPicks[j].getBestPhaseCode(),
                ttArrivals[j].getPhaseCode(),
                probability,
                observabilityAmp,
                boost));

        cumulativeFoM *= observabilityAmp * probability * boost;
      }
    }

    LOGGER.trace(
        String.format("Cum: %10.4e %10.4e", cumulativeFoM, currentGroup.getCumulativeFoM()));

    // Make a second pass if this is the highest figure-of-merit yet.  Note,
    // the Fortran version has greater than or equal to.
    if (cumulativeFoM > currentGroup.getCumulativeFoM()) {
      currentGroup.setCumulativeFoM(cumulativeFoM);

      for (int j = 0; j < ttArrivals.length; j++) {
        if (!obsPicks[j].getIsSurfaceWave()) {
          obsPicks[j].setStatisticalFoM(ttArrivals[j], computeResidual(obsPicks[j], ttArrivals[j]));
        }
      }
    }
  }

  /**
   * This function computes the modified theoretical phase "amplitude". This is the phase
   * observability with empirical modifiers to reflect how closely it matches the observed phase.
   * Note that this is a complicated function of who identified the observed phase, if they are in
   * the same phase group, and if they have the same phase type. The sticky weight promotes
   * stability by tending to keep the old identification all else being equal.
   *
   * @param pick A Pick object containing the pick information for one pick
   * @param travelTime A TravelTimeData object holding arrival time information for one arrival
   * @return A double containing the "amplitude" or observability which has been modified by
   *     empirical weights
   */
  private double computeObsAmplitude(Pick pick, TravelTimeData travelTime) {
    // Set up the observed pick phase group.
    // Note depends on the lastPick class variable being set
    if (!pick.equals(lastPick)) {
      lastPick = pick;
      currPhaseGroupName =
          auxiliaryTTInfo.findGroup(
              pick.getBestPhaseCode(), (pick.getOriginalAuthorType() == AuthorType.CONTRIB_AUTO));
      isPrimary = auxiliaryTTInfo.getIsPrimaryGroup();

      if ("Any".equals(currPhaseGroupName) || pick.getBestPhaseCode().equals(currPhaseGroupName)) {
        isGeneric = true;
      } else {
        isGeneric = false;
      }

      LOGGER.trace("New " + currPhaseGroupName);
      if (isPrimary) {
        LOGGER.trace(" Pri");
      }
      if (isGeneric) {
        LOGGER.trace(" Gen");
      }
    } else {
      LOGGER.trace("Old");
    }

    // initialize the observability amplitude.
    double observabilityAmp;
    if (!travelTime.getAssocDownWeight()) {
      observabilityAmp = travelTime.getObservability();
    } else {
      observabilityAmp = LocUtil.DOWNWEIGHT * travelTime.getObservability();
      LOGGER.trace(" Down");
    }

    // Do the group logic.  If the phase codes match drop through
    // unless the phase might be generic.
    if ((!pick.getBestPhaseCode().equals(travelTime.getPhaseCode()) || isGeneric)
        && !"Any".equals(currPhaseGroupName)) {
      // Handle primary groups differently for generic phase codes.
      if (isGeneric && isPrimary) {
        // If the observed phase group matches the primary or auxiliary
        // groups of the theoretical phase use the group weighting.  That
        // is, a generic P might be either a P or a PKP.  The "Reg" group
        // is a special case for contributed automatic picks (typically
        // from regional networks) which are assumed to be regional.
        if (currPhaseGroupName.equals(travelTime.getGroupPhaseCode())
            || currPhaseGroupName.equals(travelTime.getAuxiliaryGroupPhaseCode())
            || ("Reg".equals(currPhaseGroupName) && travelTime.getIsRegional())) {
          observabilityAmp *= LocUtil.GROUPWEIGHT;

          LOGGER.trace(" Group1");
        } else {
          // Otherwise use the other (non-group) weighting.
          observabilityAmp *= otherWeight;

          LOGGER.trace(" Other1");

          // If we trust the phase identification and the arrival types
          // of the phases don't match, make re-identifying even harder
          if (!pick.getIsAutomatic()
              && TauUtilities.classifyPhaseWaveType(currPhaseGroupName)
                  != TauUtilities.classifyPhaseWaveType(travelTime.getPhaseCode())) {
            observabilityAmp *= LocUtil.TYPEWEIGHT;

            LOGGER.trace(" Type1");
          }
        }
      } else {
        // If the observed phase group matches the primary group of the
        // theoretical phase use the group weighting.  That is, a Pn would
        // be in the same group as Pg, but not PKPdf.  Note that a generic
        // PKP would only match PKP phases.
        if (currPhaseGroupName.equals(travelTime.getGroupPhaseCode())) {
          observabilityAmp *= LocUtil.GROUPWEIGHT;

          LOGGER.trace(" Group2");
        } else {
          // Otherwise use the other (non-group) weighting.
          observabilityAmp *= otherWeight;

          LOGGER.trace(" Other2");

          // If we trust the phase identification and the arrival types
          // of the phases don't match, make re-identifying even harder
          if (!pick.getIsAutomatic()
              && TauUtilities.classifyPhaseWaveType(currPhaseGroupName)
                  != TauUtilities.classifyPhaseWaveType(travelTime.getPhaseCode())) {
            observabilityAmp *= LocUtil.TYPEWEIGHT;

            LOGGER.trace(" Type2");
          }
        }
      }
    }

    // Account for the affinity.
    if (pick.getBestPhaseCode().equals(travelTime.getPhaseCode())) {
      observabilityAmp *= pick.getOriginalPhaseAffinity();

      LOGGER.trace(" Aff");
    }

    // Make the existing identification harder to change.
    if (pick.getCurrentPhaseCode().equals(travelTime.getPhaseCode())) {
      observabilityAmp *= stickyWeight;

      LOGGER.trace(" Sticky");
    }

    return observabilityAmp;
  }

  /**
   * This function computes the affinity weighted travel-time residual.
   *
   * @param pick A Pick object containing the pick information for one pick
   * @param travelTime A TravelTimeData object holding arrival time information for one arrival
   * @return A double containing the affinity weighted residual
   */
  private double computeResidual(Pick pick, TravelTimeData travelTime) {
    if (pick.getBestPhaseCode().equals(travelTime.getPhaseCode())) {
      return Math.abs(pick.getTravelTime() - travelTime.getTravelTime())
          / pick.getOriginalPhaseAffinity();
    } else {
      return Math.abs(pick.getTravelTime() - travelTime.getTravelTime()) / LocUtil.NULLAFFINITY;
    }
  }
}
