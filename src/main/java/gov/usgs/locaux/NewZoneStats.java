package gov.usgs.locaux;

import gov.usgs.locator.BayesianDepth;
import gov.usgs.locator.DepthSource;
import java.io.IOException;
import java.io.Serializable;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This class implements the new zone statistics generated by Will Yeck using the EHB data set. Note
 * that this version supports the first cut with only one mean depth per sample point, making it a
 * drop in replacement for the old zone statistics. Like the old zone statistics, the new zone
 * statistics are sparse. That is, most points will have no earthquakes within their averaging
 * radius and hence no statistics. Despite the sparseness, it turned out to be convenient to
 * initialize all latitude rows. However, rows with no statistics don't allocate storage for the
 * longitude points. Also, by extending an abstract zone statistics class, it will be possible to
 * run the new and old zone statistics in parallel.
 *
 * @author Ray Buland
 */
public class NewZoneStats extends AbstractZoneStats implements Serializable {
  /**
   * A long containing the serializable class version number, used during deserialization to verify
   * compatibility.
   */
  private static final long serialVersionUID = 1L;

  /** Array containing NewZoneRow objects holding the latitude rows. */
  private NewZoneRow[] latRows;

  /** An AuxLocRef object containing the legacy zonestats for testing */
  protected static AuxLocRef auxLoc;

  /** Private logging object. */
  private static final Logger LOGGER = LogManager.getLogger(NewZoneStats.class.getName());

  /**
   * NewZoneStats Constructor. Initialize ZoneStats storage.
   *
   * @param firstRowLat Geographic latitude of the first row in degrees
   * @param lastRowLat Geographic latitude of the last row in degrees
   * @param latSpacing Latitude grid spacing in degrees
   * @param numLats Number of latitude rows
   */
  public NewZoneStats(double firstRowLat, double lastRowLat, double latSpacing, int numLats) {
    // Internally, everything is in colatitude.
    this.firstRowLat = 90d - firstRowLat;
    this.lastRowLat = 90d - lastRowLat;
    this.latSpacing = latSpacing;
    latRows = new NewZoneRow[numLats];
  }

  /**
   * Function to initialize a new latitude row.
   *
   * @param row Row index
   * @param lat The geographical latitude in degrees
   * @param lonSpacing The spacing of longitude points in degrees
   * @param numLons The total number of longitude samples
   */
  public void initRow(int row, double lat, double lonSpacing, int numLons) {
    // Internally, everything is in colatitude.
    latRows[row] = new NewZoneRow(90d - lat, lonSpacing, numLons);
  }

  /**
   * Get the row colatitude.
   *
   * @param row Latitude row index
   * @return Row geographic colatitude in degrees
   */
  public double getLat(int row) {
    return latRows[row].getLat();
  }

  /**
   * Function to get the number of longitudes in a latitude row.
   *
   * @param row Latitude row index
   * @return The number of longitudes in the latitude row
   */
  public int getNumLons(int row) {
    return latRows[row].getNumLons();
  }

  /**
   * Function to get the longitude spacing in a latitude row.
   *
   * @param row Latitude row index
   * @return The longitude spacing in degrees in the latitude row
   */
  public double getLonSpacing(int row) {
    return latRows[row].getLonSpacing();
  }

  /**
   * Function to add a longitude sample point statistic for latitude row at the given longitude
   * index.
   *
   * @param row Latitude row index
   * @param column The longitude column index
   * @param stats ZoneStats statistics for this longitude
   */
  public void putSample(int row, int column, NewZonePoint stats) {
    latRows[row].putSample(column, stats);
  }

  /**
   * Function to get a longitude sample point statistic from this latitude row at the given
   * longitude index.
   *
   * @param row Latitude row index
   * @param column The longitude column index
   * @return ZoneStats statistics for this longitude
   */
  public NewZonePoint getSample(int row, int column) {
    return latRows[row].getSample(column);
  }

  /**
   * Function to get the raw depth statistics by latitude/longitude.
   *
   * @param latitude A double containing the geographic latitude in degrees
   * @param longitude A double containing the geographic longitude in degrees
   * @return A NewZonePoint object containing the zone statistics
   */
  public NewZonePoint getStats(double latitude, double longitude) {
    // Get the ZoneStat indices.
    computeCanonicalCoords(latitude, longitude);

    if (Double.isNaN(coLat) || Double.isNaN(coLon)) {
      return null;
    }

    getIndices();

    // Get the statistics.
    return getStats(latIndex, lonIndex);
  }

  /**
   * Function to get the raw depth statistics by latitude/longitude indices.
   *
   * @param latIndex ZoneStats colatitude index
   * @param lonIndex ZoneStats longitude index
   * @return A NewZonePoint object containing the zone statistics
   */
  public NewZonePoint getStats(int latIndex, int lonIndex) {
    return latRows[latIndex].getSample(lonIndex);
  }

  /**
   * Function to compute the Bayesian depth from the ZoneStats information. Note that this returns
   * the values from the nearest grid point.
   *
   * @param latIndex The colatitude row index
   * @param lonIndex The longitude row index
   * @return A BayesianDepth object containing the summary of the depth statistics
   */
  @Override
  public BayesianDepth getBayesDepth(int latIndex, int lonIndex) {
    NewZonePoint point;

    point = getStats(latIndex, lonIndex);
    if (point != null) {
      return new BayesianDepth(
          point.getDepth(),
          Math.max(point.getDepthError(), LocUtil.DEFAULTDEPTHSE),
          getDepthSource());
    } else {
      return null;
    }
  }

  /**
   * Function to get depth source type for this ZoneStats
   *
   * @return A DepthSource containing the depth source identification string
   */
  @Override
  protected DepthSource getDepthSource() {
    return DepthSource.NEWZONESTATS;
  }

  /**
   * Function to convert coordinates from geographic latitude and longitude to geographic colatitude
   * and longitude in the range 0 to 360 degrees. These coordinates are remembered as coLat and
   * coLon.
   *
   * @param lat Geographic latitude in degrees
   * @param lon Geographic longitude in degrees
   */
  @Override
  protected void computeCanonicalCoords(double lat, double lon) {
    // We need colatitude (0-180) and longitude in the range of 0-360.
    coLat = 90d - lat;
    coLon = (lon >= 0d) ? lon : lon + 360d;

    // Make sure the coordinates are OK.
    if (coLat > 180d || coLat < 0d) {
      coLat = Double.NaN;
    }
    if (coLon > 360d || coLon < 0d) {
      coLon = Double.NaN;
    }
  }

  /**
   * Function to compute the latitude index of the nearest latitude row.
   *
   * @param coLat Geographical colatitude in degrees
   * @return Integer containing the index of the nearest latitude row
   */
  @Override
  protected int newLatIndex(double coLat) {
    return Math.min((int) (coLat / latSpacing), latRows.length - 1);
  }

  /**
   * Function to compute the longitude index of the nearest longitude sample.
   *
   * @param latIndex Index of the nearest latitude row
   * @param coLon Geographic longitude in degrees (0-360)
   * @return Integer containing the index of the nearest longitude sample
   */
  @Override
  protected int newLonIndex(int latIndex, double coLon) {
    return Math.min(
        (int)
            (((coLon + 0.5d * latRows[latIndex].getLonSpacing()) % 360d)
                / latRows[latIndex].getLonSpacing()),
        latRows[latIndex].getNumLons() - 1);
  }

  /**
   * Function to wrap the longitude.
   *
   * <p>When looking for neighboring samples in longitude, it may be necessary to wrap the longitude
   * index.
   *
   * @param latIndex Colatitude row index
   * @param lonIndex Longitude column index
   * @return Integer containing the valid longitude column index
   */
  @Override
  protected int wrapLonIndex(int latIndex, int lonIndex) {
    if (lonIndex >= 0 && lonIndex < latRows[latIndex].getNumLons()) {
      return lonIndex;
    } else {
      if (lonIndex < 0) {
        return latRows[latIndex].getNumLons() + lonIndex;
      } else {
        return lonIndex - latRows[latIndex].getNumLons();
      }
    }
  }

  /**
   * Function to compute the geographic colatitude of the indexed latitude row (i.e., the colatitude
   * of the samples in this row).
   *
   * @param latIndex Index of a latitude row
   * @return Double containing geographic colatitude in degrees
   */
  @Override
  protected double latFromIndex(int latIndex) {
    double coLat = firstRowLat + latIndex * latSpacing;
    if (coLat < 0d || coLat > 180d) {
      coLat = Double.NaN;
    }
    return coLat;
  }

  /**
   * Function to compute the geographic longitude of the indexed sample point.
   *
   * @param latIndex Index of a latitude row
   * @param lonIndex Index of a longitude sample
   * @return Double containing geographic longitude in degrees (0-360)
   */
  @Override
  protected double lonFromIndex(int latIndex, int lonIndex) {
    return (lonIndex * latRows[latIndex].getLonSpacing()) % 360d;
  }

  /**
   * Main function to act as the driver for a test of the ZoneStats/SlabModel subsystem.
   *
   * @param args Not used
   * @throws IOException On auxiliary data read error
   * @throws ClassNotFoundException On auxiliary data serialization error
   */
  public static void main(String[] args) throws ClassNotFoundException, IOException {
    String modelPath = "../../LocRun/models/";

    auxLoc = new AuxLocRef(modelPath, modelPath);
    NewZoneStats test = auxLoc.getNewZoneStats();
    test.doTest();
  }

  /**
   * NewZoneStats test function
   *
   * <p>Do the actual tests here to avoid making everything static.
   */
  public void doTest() {
    int maxTrials = 1000, depthFound = 0;
    double lat, lon;
    BayesianDepth bayesNew, bayesOld;

    ZoneStats zoneStats = auxLoc.getZoneStats();
    for (int i = 0; i < maxTrials; i++) {
      // Generate the hypocenter.
      lat = 180d * (Math.random() - 0.5d);
      lon = 360d * (Math.random() - 0.5d);

      // Run the Bayesian depth algorithm.
      bayesNew = interpolateBayesDepth(lat, lon);
      if (bayesNew != null) {
        depthFound++;
        bayesOld = zoneStats.interpolateBayesDepth(lat, lon);

        if (bayesOld != null) {
          if (Math.abs(bayesNew.getDepth() - bayesOld.getDepth())
              > Math.max(30d, 0.2 * Math.max(bayesNew.getDepth(), bayesOld.getDepth()))) {
            LOGGER.info(
                "New: i = %5d lat = %8.4f lon = %9.4f depth = %6.2f +/- %6.2f\n",
                i, lat, lon, bayesNew.getDepth(), bayesNew.getSpread());

            LOGGER.info(
                "Old: i = %5d lat = %8.4f lon = %9.4f depth = %6.2f +/- %6.2f\n",
                i, lat, lon, bayesOld.getDepth(), bayesOld.getSpread());
          }
        }
      }
    }

    LOGGER.info("A valid depth was found in %6.2f%% of cases.\n", (100d * depthFound) / maxTrials);
  }
}
